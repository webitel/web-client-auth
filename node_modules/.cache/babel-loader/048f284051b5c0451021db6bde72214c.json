{"remainingRequest":"/home/dev/work/client-auth/node_modules/babel-loader/lib/index.js!/home/dev/work/client-auth/src/directives/clickaway.js","dependencies":[{"path":"/home/dev/work/client-auth/src/directives/clickaway.js","mtime":1580983293932},{"path":"/home/dev/work/client-auth/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/dev/work/client-auth/node_modules/babel-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":["var HANDLER = '_vue_clickaway_handler';\n\nfunction bind(el, binding, vnode) {\n  unbind(el);\n  var vm = vnode.context;\n  var callback = binding.value; // @NOTE: Vue binds directives in microtasks, while UI events are dispatched\n  //        in macrotasks. This causes the listener to be set up before\n  //        the \"origin\" click event (the event that lead to the binding of\n  //        the directive) arrives at the document root. To work around that,\n  //        we ignore events until the end of the \"initial\" macrotask.\n  // @REFERENCE: https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/\n  // @REFERENCE: https://github.com/simplesmiler/vue-clickaway/issues/8\n\n  var initialMacrotaskEnded = false;\n  setTimeout(function () {\n    initialMacrotaskEnded = true;\n  }, 0);\n\n  el[HANDLER] = function (ev) {\n    // @NOTE: this test used to be just `el.contains`, but working with path is better,\n    //        because it tests whether the element was there at the time of\n    //        the click, not whether it is there now, that the event has arrived\n    //        to the top.\n    // @NOTE: `.path` is non-standard, the standard way is `.composedPath()`\n    var path = ev.path || (ev.composedPath ? ev.composedPath() : undefined);\n\n    if (initialMacrotaskEnded && (path ? path.indexOf(el) < 0 : !el.contains(ev.target))) {\n      return callback.call(vm, ev);\n    }\n  };\n\n  document.documentElement.addEventListener('click', el[HANDLER], false);\n}\n\nfunction unbind(el) {\n  document.documentElement.removeEventListener('click', el[HANDLER], false);\n  delete el[HANDLER];\n}\n\nvar clickaway = {\n  bind: bind,\n  update: function update(el, binding) {\n    if (binding.value === binding.oldValue) return;\n    bind(el, binding);\n  },\n  unbind: unbind\n};\nexport default clickaway;",{"version":3,"sources":["/home/dev/work/client-auth/src/directives/clickaway.js"],"names":["HANDLER","bind","el","binding","vnode","unbind","vm","context","callback","value","initialMacrotaskEnded","setTimeout","ev","path","composedPath","undefined","indexOf","contains","target","call","document","documentElement","addEventListener","removeEventListener","clickaway","update","oldValue"],"mappings":"AAAA,IAAMA,OAAO,GAAG,wBAAhB;;AAEA,SAASC,IAAT,CAAcC,EAAd,EAAkBC,OAAlB,EAA2BC,KAA3B,EAAkC;AAC9BC,EAAAA,MAAM,CAACH,EAAD,CAAN;AAEA,MAAMI,EAAE,GAAGF,KAAK,CAACG,OAAjB;AACA,MAAMC,QAAQ,GAAGL,OAAO,CAACM,KAAzB,CAJ8B,CAM9B;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,MAAIC,qBAAqB,GAAG,KAA5B;AACAC,EAAAA,UAAU,CAAC,YAAW;AAClBD,IAAAA,qBAAqB,GAAG,IAAxB;AACH,GAFS,EAEP,CAFO,CAAV;;AAIAR,EAAAA,EAAE,CAACF,OAAD,CAAF,GAAc,UAASY,EAAT,EAAa;AACvB;AACA;AACA;AACA;AACA;AACA,QAAMC,IAAI,GAAGD,EAAE,CAACC,IAAH,KAAYD,EAAE,CAACE,YAAH,GAAkBF,EAAE,CAACE,YAAH,EAAlB,GAAsCC,SAAlD,CAAb;;AACA,QAAIL,qBAAqB,KAAKG,IAAI,GAAGA,IAAI,CAACG,OAAL,CAAad,EAAb,IAAmB,CAAtB,GAA0B,CAACA,EAAE,CAACe,QAAH,CAAYL,EAAE,CAACM,MAAf,CAApC,CAAzB,EAAsF;AAClF,aAAOV,QAAQ,CAACW,IAAT,CAAcb,EAAd,EAAkBM,EAAlB,CAAP;AACH;AACJ,GAVD;;AAYAQ,EAAAA,QAAQ,CAACC,eAAT,CAAyBC,gBAAzB,CAA0C,OAA1C,EAAmDpB,EAAE,CAACF,OAAD,CAArD,EAAgE,KAAhE;AACH;;AAED,SAASK,MAAT,CAAgBH,EAAhB,EAAoB;AAChBkB,EAAAA,QAAQ,CAACC,eAAT,CAAyBE,mBAAzB,CAA6C,OAA7C,EAAsDrB,EAAE,CAACF,OAAD,CAAxD,EAAmE,KAAnE;AACA,SAAOE,EAAE,CAACF,OAAD,CAAT;AACH;;AAED,IAAMwB,SAAS,GAAG;AACdvB,EAAAA,IAAI,EAAJA,IADc;AAEdwB,EAAAA,MAFc,kBAENvB,EAFM,EAEFC,OAFE,EAEO;AACjB,QAAIA,OAAO,CAACM,KAAR,KAAkBN,OAAO,CAACuB,QAA9B,EAAwC;AACxCzB,IAAAA,IAAI,CAACC,EAAD,EAAKC,OAAL,CAAJ;AACH,GALa;AAMdE,EAAAA,MAAM,EAANA;AANc,CAAlB;AASA,eAAemB,SAAf","sourcesContent":["const HANDLER = '_vue_clickaway_handler';\n\nfunction bind(el, binding, vnode) {\n    unbind(el);\n\n    const vm = vnode.context;\n    const callback = binding.value;\n\n    // @NOTE: Vue binds directives in microtasks, while UI events are dispatched\n    //        in macrotasks. This causes the listener to be set up before\n    //        the \"origin\" click event (the event that lead to the binding of\n    //        the directive) arrives at the document root. To work around that,\n    //        we ignore events until the end of the \"initial\" macrotask.\n    // @REFERENCE: https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/\n    // @REFERENCE: https://github.com/simplesmiler/vue-clickaway/issues/8\n    let initialMacrotaskEnded = false;\n    setTimeout(function() {\n        initialMacrotaskEnded = true;\n    }, 0);\n\n    el[HANDLER] = function(ev) {\n        // @NOTE: this test used to be just `el.contains`, but working with path is better,\n        //        because it tests whether the element was there at the time of\n        //        the click, not whether it is there now, that the event has arrived\n        //        to the top.\n        // @NOTE: `.path` is non-standard, the standard way is `.composedPath()`\n        const path = ev.path || (ev.composedPath ? ev.composedPath() : undefined);\n        if (initialMacrotaskEnded && (path ? path.indexOf(el) < 0 : !el.contains(ev.target))) {\n            return callback.call(vm, ev);\n        }\n    };\n\n    document.documentElement.addEventListener('click', el[HANDLER], false);\n}\n\nfunction unbind(el) {\n    document.documentElement.removeEventListener('click', el[HANDLER], false);\n    delete el[HANDLER];\n}\n\nconst clickaway = {\n    bind,\n    update (el, binding) {\n        if (binding.value === binding.oldValue) return;\n        bind(el, binding);\n    },\n    unbind,\n};\n\nexport default clickaway;"]}]}