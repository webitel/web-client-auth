import { __awaiter, __extends, __generator } from "tslib";
import { EventEmitter } from 'ee-ts';
import * as SipClient from 'jssip';
import { Log } from './log';
var SipPhone = /** @class */ (function (_super) {
    __extends(SipPhone, _super);
    function SipPhone(instanceId) {
        var _this = _super.call(this) || this;
        _this.instanceId = instanceId;
        _this.sessionCache = new Map();
        SipClient.debug.enable('*');
        _this.log = new Log();
        _this.on('unregistered', function () {
            _this.ua.removeAllListeners();
            delete _this.ua;
            _this.sessionCache.clear();
        });
        return _this;
    }
    SipPhone.prototype.getMediaConstraints = function (req) {
        if (req.useScreen) {
            return {
                video: false,
                audio: false,
                screen: true,
            };
        }
        return {
            video: req.useVideo || false,
            audio: req.useAudio || true,
        };
    };
    SipPhone.prototype.callOption = function (req) {
        return {
            sessionTimersExpires: 120,
            pcConfig: {
                iceServers: [{ urls: ['stun:stun.l.google.com:19302'] }],
            },
            rtcOfferConstraints: {
                offerToReceiveAudio: req.useAudio || true,
                offerToReceiveVideo: req.useVideo,
            },
            mediaConstraints: this.getMediaConstraints(req),
        };
    };
    SipPhone.prototype.getSession = function (id) {
        if (this.sessionCache.has(id)) {
            return this.sessionCache.get(id);
        }
        return null;
    };
    SipPhone.prototype.hasSession = function (id) {
        return this.sessionCache.has(id);
    };
    SipPhone.prototype.getPeerStream = function (id) {
        var session = this.getSession(id);
        if (session && session.sip.connection) {
            // @ts-ignore
            var streams = session.sip.connection.getRemoteStreams();
            if (streams && streams.length) {
                return streams;
            }
        }
        return null;
    };
    SipPhone.prototype.answer = function (id, req) {
        if (this.sessionCache.has(id)) {
            var session = this.sessionCache.get(id);
            session.sip.answer(this.callOption(req));
            return true;
        }
        return false;
    };
    SipPhone.prototype.register = function (sipConf) {
        return __awaiter(this, void 0, void 0, function () {
            var socket, configuration, ua;
            var _this = this;
            return __generator(this, function (_a) {
                socket = new SipClient.WebSocketInterface(sipConf.server);
                configuration = {
                    realm: sipConf.realm,
                    uri: sipConf.uri,
                    authorization_user: sipConf.authorization_user,
                    ha1: sipConf.ha1,
                    user_agent: SipPhone.userAgent,
                    sockets: [socket],
                    session_timers: true,
                    // use_preloaded_route: true,
                    register_expires: 300,
                    connection_recovery_min_interval: 5,
                    connection_recovery_max_interval: 60,
                };
                ua = (this.ua = new SipClient.UA(configuration));
                ua.on('connected', function (e) {
                    _this.log.error('connected', e);
                });
                ua.on('newRTCSession', function (e) {
                    var session = e.session;
                    var id = e.request.getHeader('X-Webitel-Uuid') || session.id;
                    var callSession = {
                        sip: session,
                        incoming: session.direction === 'incoming',
                        instance_id: e.request.getHeader('X-Webitel-Sock-Id'),
                    };
                    _this.storeSession(id, callSession);
                    session.on('peerconnection', function (peer) {
                        peer.peerconnection.addEventListener('addstream', function (evt) { return __awaiter(_this, void 0, void 0, function () {
                            return __generator(this, function (_a) {
                                // set remote audio stream
                                this.emit('peerStreams', id, new Array(evt.stream));
                                return [2 /*return*/];
                            });
                        }); });
                    });
                    session.on('ended', function () {
                        // this handler will be called for incoming calls too
                        _this.removeSession(id);
                    });
                    session.on('failed', function () {
                        // this handler will be called for incoming calls too
                        _this.removeSession(id);
                    });
                    session.on('accepted', function () {
                        // the call has answered
                        if (!_this.isOutboundCall(id)) {
                            _this.emit('peerStreams', id, _this.getPeerStream(id));
                        }
                    });
                    session.on('confirmed', function () {
                        // this handler will be called for incoming calls too
                    });
                    _this.emit('newSession', id, callSession);
                });
                ua.on('disconnected', function (e) {
                    _this.log.error('disconnected', e);
                    _this.emit('unregistered');
                });
                ua.on('registered', function (e) {
                    _this.log.error('registered', e);
                });
                ua.on('unregistered', function (e) {
                    _this.log.error('unregistered', e);
                    _this.emit('unregistered');
                });
                ua.on('registrationFailed', function (e) {
                    _this.log.error('registrationFailed', e);
                });
                ua.on('error', function (e) {
                    _this.emit('error', e);
                    _this.log.error('error', e);
                });
                ua.start();
                return [2 /*return*/];
            });
        });
    };
    SipPhone.prototype.isOutboundCall = function (id) {
        var session = this.getSession(id);
        if (session) {
            return session.incoming && session.instance_id === this.instanceId;
        }
        return false;
    };
    SipPhone.prototype.unregister = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                if (this.ua) {
                    this.ua.unregister();
                }
                return [2 /*return*/];
            });
        });
    };
    Object.defineProperty(SipPhone.prototype, "allSession", {
        get: function () {
            return Array.from(this.sessionCache.values());
        },
        enumerable: true,
        configurable: true
    });
    SipPhone.prototype.removeSession = function (id) {
        if (this.sessionCache.has(id)) {
            this.sessionCache.delete(id);
            return true;
        }
        return false;
    };
    SipPhone.prototype.storeSession = function (id, session) {
        if (this.sessionCache.has(id)) {
            throw new Error('Session already store');
        }
        this.sessionCache.set(id, session);
    };
    SipPhone.userAgent = 'Webitel-Phone/0.0.1';
    return SipPhone;
}(EventEmitter));
export { SipPhone };
//# sourceMappingURL=sip.js.map