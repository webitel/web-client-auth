import { __awaiter, __generator } from "tslib";
import { EventEmitter } from 'ee-ts';
import { Call, CallActions, } from './call';
import { Log } from './log';
import { SipPhone } from './sip';
import { Socket } from './socket';
var WEBSOCKET_AUTHENTICATION_CHALLENGE = 'authentication_challenge';
var WEBSOCKET_DEFAULT_DEVICE_CONFIG = 'user_default_device';
var WEBSOCKET_MAKE_OUTBOUND_CALL = 'call_invite';
var WEBSOCKET_MAKE_USER_CALL = 'call_user';
var WEBSOCKET_EVENT_HELLO = 'hello';
var WEBSOCKET_EVENT_CALL = 'call';
var WEBSOCKET_EVENT_SIP = 'sip';
export var Response;
(function (Response) {
    Response["STATUS_FAIL"] = "FAIL";
    Response["STATUS_OK"] = "OK";
})(Response || (Response = {}));
var Client = /** @class */ (function () {
    function Client(_config) {
        this._config = _config;
        this.reqSeq = 0;
        this.queueRequest = new Map();
        this.log = new Log();
        this.eventHandler = new EventEmitter();
        this.callStore = new Map();
    }
    Client.prototype.connect = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.connectToSocket()];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    Client.prototype.disconnect = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                this.socket.close();
                return [2 /*return*/];
            });
        });
    };
    Client.prototype.subscribeCall = function (handler, data) {
        return __awaiter(this, void 0, void 0, function () {
            var res;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.request("subscribe_call", data)];
                    case 1:
                        res = _a.sent();
                        this.eventHandler.on(WEBSOCKET_EVENT_CALL, handler);
                        return [2 /*return*/, res];
                }
            });
        });
    };
    Client.prototype.unSubscribe = function (action, handler, data) {
        return __awaiter(this, void 0, void 0, function () {
            var res;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.request("un_subscribe_" + action, data)
                        // this.eventHandler.listeners(action)
                        // this.eventHandler.removeListener(action, handler)
                        // this.eventHandler.off(action, handler)
                    ];
                    case 1:
                        res = _a.sent();
                        // this.eventHandler.listeners(action)
                        // this.eventHandler.removeListener(action, handler)
                        // this.eventHandler.off(action, handler)
                        return [2 /*return*/, res];
                }
            });
        });
    };
    Client.prototype.allCall = function () {
        return Array.from(this.callStore.values());
    };
    Client.prototype.callById = function (id) {
        if (this.callStore.has(id)) {
            return this.callStore.get(id);
        }
        return undefined;
    };
    Client.prototype.auth = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.request(WEBSOCKET_AUTHENTICATION_CHALLENGE, {
                        token: this._config.token,
                    })];
            });
        });
    };
    Client.prototype.sessionInfo = function () {
        return this.connectionInfo.session;
    };
    Object.defineProperty(Client.prototype, "version", {
        get: function () {
            return this.connectionInfo.server_version;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Client.prototype, "instanceId", {
        get: function () {
            return this.connectionInfo.sock_id;
        },
        enumerable: true,
        configurable: true
    });
    Client.prototype.invite = function (req) {
        return this.request(WEBSOCKET_MAKE_OUTBOUND_CALL, req);
    };
    Client.prototype.inviteToUser = function (req) {
        return this.request(WEBSOCKET_MAKE_USER_CALL, req);
    };
    Client.prototype.answer = function (id, req) {
        return this.phone.answer(id, req);
    };
    Client.prototype.request = function (action, data) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this.queueRequest.set(++_this.reqSeq, { resolve: resolve, reject: reject });
            _this.socket.send({
                seq: _this.reqSeq,
                action: action,
                data: data,
            });
        });
    };
    Client.prototype.useWebPhone = function () {
        return this._config.registerWebDevice || false;
    };
    Client.prototype.deviceConfig = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.request(WEBSOCKET_DEFAULT_DEVICE_CONFIG, {})];
            });
        });
    };
    Client.prototype.onMessage = function (message) {
        return __awaiter(this, void 0, void 0, function () {
            var promise, _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        this.log.debug('receive message: ', message);
                        if (!(message.seq_reply > 0)) return [3 /*break*/, 1];
                        if (this.queueRequest.has(message.seq_reply)) {
                            promise = this.queueRequest.get(message.seq_reply);
                            this.queueRequest.delete(message.seq_reply);
                            if (message.status === Response.STATUS_OK) {
                                promise.resolve(message.data);
                            }
                            else {
                                promise.reject(message.error);
                            }
                        }
                        return [3 /*break*/, 7];
                    case 1:
                        _a = message.event;
                        switch (_a) {
                            case WEBSOCKET_EVENT_HELLO: return [3 /*break*/, 2];
                            case WEBSOCKET_EVENT_CALL: return [3 /*break*/, 4];
                            case WEBSOCKET_EVENT_SIP: return [3 /*break*/, 5];
                        }
                        return [3 /*break*/, 6];
                    case 2: return [4 /*yield*/, this.connected(message.data)];
                    case 3:
                        _b.sent();
                        this.log.debug("opened session " + this.connectionInfo.sock_id + " for userId=" + this.connectionInfo.session.user_id);
                        return [3 /*break*/, 7];
                    case 4:
                        this.handleCallEvents(message.data.call);
                        return [3 /*break*/, 7];
                    case 5:
                        this.eventHandler.emit(WEBSOCKET_EVENT_SIP, message.data);
                        return [3 /*break*/, 7];
                    case 6:
                        this.log.error("event " + message.event + " not handler");
                        _b.label = 7;
                    case 7: return [2 /*return*/];
                }
            });
        });
    };
    Client.prototype.connected = function (info) {
        return __awaiter(this, void 0, void 0, function () {
            var conf, e_1;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this.connectionInfo = info;
                        this.phone = new SipPhone(this.instanceId);
                        this.phone.on('peerStreams', function (id, streams) {
                            var call = _this.callById(id);
                            if (call && call.peerStreams === null) {
                                call.setPeerStreams(streams);
                                _this.eventHandler.emit(WEBSOCKET_EVENT_CALL, CallActions.PeerStream, call);
                            }
                        });
                        this.phone.on('newSession', this.onNewCallSession.bind(this));
                        if (!this.useWebPhone()) return [3 /*break*/, 5];
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 4, , 5]);
                        return [4 /*yield*/, this.deviceConfig()];
                    case 2:
                        conf = _a.sent();
                        return [4 /*yield*/, this.phone.register(conf)];
                    case 3:
                        _a.sent();
                        return [3 /*break*/, 5];
                    case 4:
                        e_1 = _a.sent();
                        // FIXME add handle error
                        this.log.error(e_1);
                        return [3 /*break*/, 5];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    Client.prototype.onNewCallSession = function (id, session) {
        this.checkAutoAnswer(id);
    };
    Client.prototype.checkAutoAnswer = function (id) {
        var call = this.callById(id);
        if (call && this.phone.isOutboundCall(id)) {
            call.answer({
                useVideo: call.videoRequest,
                useScreen: call.screenRequest,
            });
        }
    };
    Client.prototype.connectToSocket = function () {
        var _this = this;
        return new Promise(function (resolve, reject) {
            try {
                _this.socket = new Socket(_this._config.endpoint);
                _this.socket.connect(_this._config.token);
            }
            catch (e) {
                reject(e);
                return;
            }
            _this.socket.on('message', _this.onMessage.bind(_this));
            _this.socket.on('close', function (code) {
                _this.log.error('socket close code: ', code);
                reject(new Error("close socket code: " + code));
            });
            _this.socket.on('open', function () {
                resolve(null);
            });
        });
    };
    Client.prototype.handleCallEvents = function (event) {
        var call;
        switch (event.action) {
            case CallActions.Ringing:
                call = new Call(this, event, this.phone.getPeerStream(event.id));
                this.callStore.set(call.id, call);
                this.checkAutoAnswer(event.id);
                break;
            case CallActions.Active:
                call = this.callById(event.id);
                if (call) {
                    call.setActive(event);
                }
                break;
            case CallActions.Bridge:
                call = this.callById(event.id);
                if (call) {
                    // const session = this.phone.getSession(event.id);
                    // if (session) {
                    //   debugger
                    // }
                    call.setInfo(event);
                }
                break;
            case CallActions.Execute:
                call = this.callById(event.id);
                if (call) {
                    call.setExecute(event);
                }
                break;
            case CallActions.DTMF:
                call = this.callById(event.id);
                if (call) {
                    call.addDigit(event);
                }
                break;
            case CallActions.Voice:
                call = this.callById(event.id);
                if (call) {
                    call.setVoice(event);
                }
                break;
            case CallActions.Silence:
                call = this.callById(event.id);
                if (call) {
                    call.setSilence(event);
                }
                break;
            case CallActions.Hold:
                call = this.callById(event.id);
                if (call) {
                    call.setState(event);
                }
                break;
            case CallActions.Hangup:
                call = this.callById(event.id);
                if (call) {
                    call.setHangup(event);
                    this.callStore.delete(call.id);
                }
                break;
            default:
                throw new Error('Unhandled action');
        }
        if (call) {
            this.eventHandler.emit(WEBSOCKET_EVENT_CALL, event.action, call);
        }
    };
    return Client;
}());
export { Client };
//# sourceMappingURL=client.js.map