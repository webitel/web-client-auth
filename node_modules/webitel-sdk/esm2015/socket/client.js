import { EventEmitter } from 'ee-ts';
import { Call, CallActions, } from './call';
import { Log } from './log';
import { SipPhone } from './sip';
import { Socket } from './socket';
const WEBSOCKET_AUTHENTICATION_CHALLENGE = 'authentication_challenge';
const WEBSOCKET_DEFAULT_DEVICE_CONFIG = 'user_default_device';
const WEBSOCKET_MAKE_OUTBOUND_CALL = 'call_invite';
const WEBSOCKET_MAKE_USER_CALL = 'call_user';
const WEBSOCKET_EVENT_HELLO = 'hello';
const WEBSOCKET_EVENT_CALL = 'call';
const WEBSOCKET_EVENT_SIP = 'sip';
export var Response;
(function (Response) {
    Response["STATUS_FAIL"] = "FAIL";
    Response["STATUS_OK"] = "OK";
})(Response || (Response = {}));
export class Client {
    constructor(_config) {
        this._config = _config;
        this.reqSeq = 0;
        this.queueRequest = new Map();
        this.log = new Log();
        this.eventHandler = new EventEmitter();
        this.callStore = new Map();
    }
    async connect() {
        await this.connectToSocket();
    }
    async disconnect() {
        this.socket.close();
    }
    async subscribeCall(handler, data) {
        const res = await this.request(`subscribe_call`, data);
        this.eventHandler.on(WEBSOCKET_EVENT_CALL, handler);
        return res;
    }
    async unSubscribe(action, handler, data) {
        const res = await this.request(`un_subscribe_${action}`, data);
        // this.eventHandler.listeners(action)
        // this.eventHandler.removeListener(action, handler)
        // this.eventHandler.off(action, handler)
        return res;
    }
    allCall() {
        return Array.from(this.callStore.values());
    }
    callById(id) {
        if (this.callStore.has(id)) {
            return this.callStore.get(id);
        }
        return undefined;
    }
    async auth() {
        return this.request(WEBSOCKET_AUTHENTICATION_CHALLENGE, {
            token: this._config.token,
        });
    }
    sessionInfo() {
        return this.connectionInfo.session;
    }
    get version() {
        return this.connectionInfo.server_version;
    }
    get instanceId() {
        return this.connectionInfo.sock_id;
    }
    invite(req) {
        return this.request(WEBSOCKET_MAKE_OUTBOUND_CALL, req);
    }
    inviteToUser(req) {
        return this.request(WEBSOCKET_MAKE_USER_CALL, req);
    }
    answer(id, req) {
        return this.phone.answer(id, req);
    }
    request(action, data) {
        return new Promise((resolve, reject) => {
            this.queueRequest.set(++this.reqSeq, { resolve, reject });
            this.socket.send({
                seq: this.reqSeq,
                action,
                data,
            });
        });
    }
    useWebPhone() {
        return this._config.registerWebDevice || false;
    }
    async deviceConfig() {
        return this.request(WEBSOCKET_DEFAULT_DEVICE_CONFIG, {});
    }
    async onMessage(message) {
        this.log.debug('receive message: ', message);
        if (message.seq_reply > 0) {
            if (this.queueRequest.has(message.seq_reply)) {
                const promise = this.queueRequest.get(message.seq_reply);
                this.queueRequest.delete(message.seq_reply);
                if (message.status === Response.STATUS_OK) {
                    promise.resolve(message.data);
                }
                else {
                    promise.reject(message.error);
                }
            }
        }
        else {
            switch (message.event) {
                case WEBSOCKET_EVENT_HELLO:
                    await this.connected(message.data);
                    this.log.debug(`opened session ${this.connectionInfo.sock_id} for userId=${this.connectionInfo.session.user_id}`);
                    break;
                case WEBSOCKET_EVENT_CALL:
                    this.handleCallEvents(message.data.call);
                    break;
                case WEBSOCKET_EVENT_SIP:
                    this.eventHandler.emit(WEBSOCKET_EVENT_SIP, message.data);
                    break;
                default:
                    this.log.error(`event ${message.event} not handler`);
            }
        }
    }
    async connected(info) {
        this.connectionInfo = info;
        this.phone = new SipPhone(this.instanceId);
        this.phone.on('peerStreams', (id, streams) => {
            const call = this.callById(id);
            if (call && call.peerStreams === null) {
                call.setPeerStreams(streams);
                this.eventHandler.emit(WEBSOCKET_EVENT_CALL, CallActions.PeerStream, call);
            }
        });
        this.phone.on('newSession', this.onNewCallSession.bind(this));
        if (this.useWebPhone()) {
            try {
                const conf = await this.deviceConfig();
                await this.phone.register(conf);
            }
            catch (e) {
                // FIXME add handle error
                this.log.error(e);
            }
        }
    }
    onNewCallSession(id, session) {
        this.checkAutoAnswer(id);
    }
    checkAutoAnswer(id) {
        const call = this.callById(id);
        if (call && this.phone.isOutboundCall(id)) {
            call.answer({
                useVideo: call.videoRequest,
                useScreen: call.screenRequest,
            });
        }
    }
    connectToSocket() {
        return new Promise((resolve, reject) => {
            try {
                this.socket = new Socket(this._config.endpoint);
                this.socket.connect(this._config.token);
            }
            catch (e) {
                reject(e);
                return;
            }
            this.socket.on('message', this.onMessage.bind(this));
            this.socket.on('close', (code) => {
                this.log.error('socket close code: ', code);
                reject(new Error(`close socket code: ${code}`));
            });
            this.socket.on('open', () => {
                resolve(null);
            });
        });
    }
    handleCallEvents(event) {
        let call;
        switch (event.action) {
            case CallActions.Ringing:
                call = new Call(this, event, this.phone.getPeerStream(event.id));
                this.callStore.set(call.id, call);
                this.checkAutoAnswer(event.id);
                break;
            case CallActions.Active:
                call = this.callById(event.id);
                if (call) {
                    call.setActive(event);
                }
                break;
            case CallActions.Bridge:
                call = this.callById(event.id);
                if (call) {
                    // const session = this.phone.getSession(event.id);
                    // if (session) {
                    //   debugger
                    // }
                    call.setInfo(event);
                }
                break;
            case CallActions.Execute:
                call = this.callById(event.id);
                if (call) {
                    call.setExecute(event);
                }
                break;
            case CallActions.DTMF:
                call = this.callById(event.id);
                if (call) {
                    call.addDigit(event);
                }
                break;
            case CallActions.Voice:
                call = this.callById(event.id);
                if (call) {
                    call.setVoice(event);
                }
                break;
            case CallActions.Silence:
                call = this.callById(event.id);
                if (call) {
                    call.setSilence(event);
                }
                break;
            case CallActions.Hold:
                call = this.callById(event.id);
                if (call) {
                    call.setState(event);
                }
                break;
            case CallActions.Hangup:
                call = this.callById(event.id);
                if (call) {
                    call.setHangup(event);
                    this.callStore.delete(call.id);
                }
                break;
            default:
                throw new Error('Unhandled action');
        }
        if (call) {
            this.eventHandler.emit(WEBSOCKET_EVENT_CALL, event.action, call);
        }
    }
}
//# sourceMappingURL=client.js.map