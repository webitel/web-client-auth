import { EventEmitter } from 'ee-ts';
import * as SipClient from 'jssip';
import { Log } from './log';
export class SipPhone extends EventEmitter {
    constructor(instanceId) {
        super();
        this.instanceId = instanceId;
        this.sessionCache = new Map();
        SipClient.debug.enable('*');
        this.log = new Log();
        this.on('unregistered', () => {
            this.ua.removeAllListeners();
            delete this.ua;
            this.sessionCache.clear();
        });
    }
    getMediaConstraints(req) {
        if (req.useScreen) {
            return {
                video: false,
                audio: false,
                screen: true,
            };
        }
        return {
            video: req.useVideo || false,
            audio: req.useAudio || true,
        };
    }
    callOption(req) {
        return {
            sessionTimersExpires: 120,
            pcConfig: {
                iceServers: [{ urls: ['stun:stun.l.google.com:19302'] }],
            },
            rtcOfferConstraints: {
                offerToReceiveAudio: req.useAudio || true,
                offerToReceiveVideo: req.useVideo,
            },
            mediaConstraints: this.getMediaConstraints(req),
        };
    }
    getSession(id) {
        if (this.sessionCache.has(id)) {
            return this.sessionCache.get(id);
        }
        return null;
    }
    hasSession(id) {
        return this.sessionCache.has(id);
    }
    getPeerStream(id) {
        const session = this.getSession(id);
        if (session && session.sip.connection) {
            // @ts-ignore
            const streams = session.sip.connection.getRemoteStreams();
            if (streams && streams.length) {
                return streams;
            }
        }
        return null;
    }
    answer(id, req) {
        if (this.sessionCache.has(id)) {
            const session = this.sessionCache.get(id);
            session.sip.answer(this.callOption(req));
            return true;
        }
        return false;
    }
    async register(sipConf) {
        const socket = new SipClient.WebSocketInterface(sipConf.server);
        const configuration = {
            realm: sipConf.realm,
            uri: sipConf.uri,
            authorization_user: sipConf.authorization_user,
            ha1: sipConf.ha1,
            user_agent: SipPhone.userAgent,
            sockets: [socket],
            session_timers: true,
            // use_preloaded_route: true,
            register_expires: 300,
            connection_recovery_min_interval: 5,
            connection_recovery_max_interval: 60,
        };
        const ua = (this.ua = new SipClient.UA(configuration));
        ua.on('connected', (e) => {
            this.log.error('connected', e);
        });
        ua.on('newRTCSession', (e) => {
            const session = e.session;
            const id = e.request.getHeader('X-Webitel-Uuid') || session.id;
            const callSession = {
                sip: session,
                incoming: session.direction === 'incoming',
                instance_id: e.request.getHeader('X-Webitel-Sock-Id'),
            };
            this.storeSession(id, callSession);
            session.on('peerconnection', (peer) => {
                peer.peerconnection.addEventListener('addstream', async (evt) => {
                    // set remote audio stream
                    this.emit('peerStreams', id, new Array(evt.stream));
                });
            });
            session.on('ended', () => {
                // this handler will be called for incoming calls too
                this.removeSession(id);
            });
            session.on('failed', () => {
                // this handler will be called for incoming calls too
                this.removeSession(id);
            });
            session.on('accepted', () => {
                // the call has answered
                if (!this.isOutboundCall(id)) {
                    this.emit('peerStreams', id, this.getPeerStream(id));
                }
            });
            session.on('confirmed', () => {
                // this handler will be called for incoming calls too
            });
            this.emit('newSession', id, callSession);
        });
        ua.on('disconnected', (e) => {
            this.log.error('disconnected', e);
            this.emit('unregistered');
        });
        ua.on('registered', (e) => {
            this.log.error('registered', e);
        });
        ua.on('unregistered', (e) => {
            this.log.error('unregistered', e);
            this.emit('unregistered');
        });
        ua.on('registrationFailed', (e) => {
            this.log.error('registrationFailed', e);
        });
        ua.on('error', (e) => {
            this.emit('error', e);
            this.log.error('error', e);
        });
        ua.start();
    }
    isOutboundCall(id) {
        const session = this.getSession(id);
        if (session) {
            return session.incoming && session.instance_id === this.instanceId;
        }
        return false;
    }
    async unregister() {
        if (this.ua) {
            this.ua.unregister();
        }
    }
    get allSession() {
        return Array.from(this.sessionCache.values());
    }
    removeSession(id) {
        if (this.sessionCache.has(id)) {
            this.sessionCache.delete(id);
            return true;
        }
        return false;
    }
    storeSession(id, session) {
        if (this.sessionCache.has(id)) {
            throw new Error('Session already store');
        }
        this.sessionCache.set(id, session);
    }
}
SipPhone.userAgent = 'Webitel-Phone/0.0.1';
//# sourceMappingURL=sip.js.map